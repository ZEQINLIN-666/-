解法：双向链表+哈希表

**我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。**

- 双向链表按照被使用的顺序存储这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。
- 哈希表即普通的哈希映射，通过缓存数据的键映射到其在双向链表中的位置。

这样一来，我们首先使用哈希表进行定位，找到缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可以在O（1）的时间内完成get或者put 的操作。

具体方法步骤：

- 对于get操作，首先判断key是否存在：

  - 如果key不存在，则返回-1；
  - 如果key存在，则key对应的节点是最近被使用的节点。接下来通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。

- 对于put操作，首先判断key是否存在。

  - 如果key不存在，则使用key和value创建新的节点，在双向链表的头部添加该节点，并将key和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量。

    如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项。（因为将节点添加到链表头部的操作就包括删除节点之后再添加的步骤，所以超容的判断放在其后。）

  - 如果key存在，则与get操作类似，先通过哈希表定位，再将对应的节点的值更新为value，并将该节点移动到双向链表的头部。

在上述的各项操作中，访问哈希表的时间复杂度都为O（1），在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为O（1）。

将一个节点移动到双向链表的头部，可以 分为两个步骤，这两个步骤都可以在O（1）时间内完成

1. 删除该节点
2. 在双向链表的头部添加节点。



注意：在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在了。



复杂度分析：

- 时间复杂度：对于put()和get()都是O(1)
- 空间复杂度:O(capacity)，因为哈希表和双向链表最多存储capacity+ 1个元素。